# Учебный проект по PyThon "2":

## *Описание:*
Создаём "E-Commerce" проект.
## *Установка:*
- Установить зависимости.
```
pip install -r requirements.txt
```
- Установка тестировщика.
```
pip install pytest
```
## *Инструкция перед началом работы*
Налейте чашечку чая, и садитесь по удобнее.
## *Примеры использования классов:*
## *Модуль 'product.py'*
### [class Product:](https://write.geeksforgeeks.org/)

Улучшенная обработка ошибок:
 - Использование walrus-оператора (:=) для проверки полей
 - Четкие сообщения об ошибках

Метод __add__:
 - Принимает только объекты класса Product
 - Возвращает сумму (price * quantity) для обоих продуктов
 - Вызывает TypeError при попытке сложить с другим типом

Дополнительные методы:
 - __str__ для красивого вывода информации
 - __eq__ для сравнения продуктов по названию

Типизация:
 - Аннотации типов для всех методов
 - Проверка типов в runtime

Безопасность:
 - Защита от неправильного использования
 - Четкие сообщения об ошибках

### *Наследование:*
1. Класс Smartphone
2. Класс LawnGrass

Оба класса наследуют базовый функционал от Product

Дополнительные атрибуты:

 - Smartphone: производительность, модель, память, цвет 
 - LawnGrass: страна, срок прорастания, цвет

Совместимость: Сохранена возможность сложения продуктов через __add__

## *Модуль 'category.py'*
### [class Category:](https://write.geeksforgeeks.org/)

Приватный атрибут товаров:
 - Список товаров хранится в __products
 - Доступ только через методы класса

Безопасное добавление товаров:
 - Метод add_product() с проверкой типа
 - Автоматическое обновление счетчиков

Форматированный вывод:
 - Геттер products возвращает строку с товарами
 - Метод __str__ для строкового представления категории

Типизация:
 - Аннотации типов для всех методов
 - Поддержка Python 3.7+ (через from __future__ import annotations)
 - Проверка типов в runtime

Обработка ошибок:
 - Четкие исключения с контекстом
 - Проверка структуры входных данных
 - Защита от некорректных состояний

## *Модуль 'loaders.py'*
### [class DataLoader:](https://write.geeksforgeeks.org/)

В вызовах _parse_data:
 - Теперь передается путь к файлу для сообщений об ошибках

Сообщения об ошибках теперь содержат:
 - Название файла, где произошла ошибка
 - Конкретное описание проблемы
 - Сохранение оригинального stack trace (через from e)

### *Пример сообщений об ошибках:*
При неверной структуре:
```
raise ValueError(f"Файл {file_path} должен содержать список категорий")
```
При отсутствии поля:
```
raise ValueError(f"Отсутствует обязательное поле в файле {file_path}: {e}")
```
При ошибке парсинга JSON:
```
raise json.JSONDecodeError(
    f"Ошибка декодирования JSON в файле {file_path}", 
    e.doc, 
    e.pos
) from e
```

## *Использования тестов:*
### [Модуль 'test_product.py ', 'test_category.py '](https://write.geeksforgeeks.org/)

 - Добавлен тест на добавление невалидного продукта
 - Проверка вывода через unittest.mock

### [Модуль 'test_loaders.py '](https://write.geeksforgeeks.org/)

 - Добавлена проверка типа возвращаемого значения
 - Проверка содержимого через публичные методы
 - Тестирование форматированного вывода товаров
 - Использование 'ensure_ascii=False' для корректного сохранения кириллицы

### Структура тестов:

Позитивные тесты:

 - test_load_valid_data - проверка корректной загрузки валидных данных
 - test_empty_products_list - проверка обработки пустого списка товаров

Негативные тесты:

 - test_file_not_found - обработка отсутствующего файла
 - test_invalid_json - обработка битого JSON
 - test_missing_required_field - проверка обязательных полей
 - test_wrong_data_structure - проверка структуры данных
 - test_file_permission_error - проверка ошибок доступа к файлу

Фикстуры:

 - setUp - создает временный JSON файл перед каждым тестом
 - tearDown - удаляет временный файл после каждого теста
